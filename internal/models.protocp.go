// Code generated by protocp; DO NOT EDIT.
package internal

import (
	"github.com/luno/jettison/internal/jettisonpb"
	"github.com/luno/jettison/models"
)

func HopToProto(namedInput *models.Hop) (*jettisonpb.Hop, error) {
	var namedOutput *jettisonpb.Hop

	var transformAndConvert models.Hop
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 jettisonpb.Hop
	transformAndConvert1.Binary = transformAndConvert.Binary
	for i := range transformAndConvert.Errors {
		var tmpOutput *jettisonpb.Error
		var transformAndConvert2 jettisonpb.Error
		transformAndConvert2.Code = transformAndConvert.Errors[i].Code
		transformAndConvert2.Message = transformAndConvert.Errors[i].Message
		for i1 := range transformAndConvert.Errors[i].Parameters {
			var tmpOutput1 *jettisonpb.KeyValue
			var transformAndConvert3 jettisonpb.KeyValue
			transformAndConvert3.Key = transformAndConvert.Errors[i].Parameters[i1].Key
			transformAndConvert3.Value = transformAndConvert.Errors[i].Parameters[i1].Value

			var transformAndConvert4 *jettisonpb.KeyValue
			transformAndConvert4 = &transformAndConvert3

			tmpOutput1 = transformAndConvert4

			transformAndConvert2.Parameters = append(transformAndConvert2.Parameters, tmpOutput1)
		}
		transformAndConvert2.Source = transformAndConvert.Errors[i].Source

		var transformAndConvert3 *jettisonpb.Error
		transformAndConvert3 = &transformAndConvert2

		tmpOutput = transformAndConvert3

		transformAndConvert1.Errors = append(transformAndConvert1.Errors, tmpOutput)
	}
	transformAndConvert1.StackTrace = ([]string)(transformAndConvert.StackTrace)

	var transformAndConvert2 *jettisonpb.Hop
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}

func HopFromProto(namedInput *jettisonpb.Hop) (*models.Hop, error) {
	var namedOutput *models.Hop

	var transformAndConvert jettisonpb.Hop
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 models.Hop
	transformAndConvert1.Binary = transformAndConvert.Binary
	for i := range transformAndConvert.Errors {
		var tmpOutput models.Error
		var transformAndConvert2 jettisonpb.Error
		if transformAndConvert.Errors[i] != nil {
			transformAndConvert2 = *transformAndConvert.Errors[i]
		}
		var transformAndConvert3 models.Error
		transformAndConvert3.Code = transformAndConvert2.Code
		transformAndConvert3.Message = transformAndConvert2.Message
		for i1 := range transformAndConvert2.Parameters {
			var tmpOutput1 models.KeyValue
			var transformAndConvert4 jettisonpb.KeyValue
			if transformAndConvert2.Parameters[i1] != nil {
				transformAndConvert4 = *transformAndConvert2.Parameters[i1]
			}
			var transformAndConvert5 models.KeyValue
			transformAndConvert5.Key = transformAndConvert4.Key
			transformAndConvert5.Value = transformAndConvert4.Value

			tmpOutput1 = transformAndConvert5

			transformAndConvert3.Parameters = append(transformAndConvert3.Parameters, tmpOutput1)
		}
		transformAndConvert3.Source = transformAndConvert2.Source

		tmpOutput = transformAndConvert3

		transformAndConvert1.Errors = append(transformAndConvert1.Errors, tmpOutput)
	}
	transformAndConvert1.StackTrace = ([]string)(transformAndConvert.StackTrace)

	var transformAndConvert2 *models.Hop
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}

func ErrorToProto(namedInput *models.Error) (*jettisonpb.Error, error) {
	var namedOutput *jettisonpb.Error

	var transformAndConvert models.Error
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 jettisonpb.Error
	transformAndConvert1.Code = transformAndConvert.Code
	transformAndConvert1.Message = transformAndConvert.Message
	for i := range transformAndConvert.Parameters {
		var tmpOutput *jettisonpb.KeyValue
		var transformAndConvert2 jettisonpb.KeyValue
		transformAndConvert2.Key = transformAndConvert.Parameters[i].Key
		transformAndConvert2.Value = transformAndConvert.Parameters[i].Value

		var transformAndConvert3 *jettisonpb.KeyValue
		transformAndConvert3 = &transformAndConvert2

		tmpOutput = transformAndConvert3

		transformAndConvert1.Parameters = append(transformAndConvert1.Parameters, tmpOutput)
	}
	transformAndConvert1.Source = transformAndConvert.Source

	var transformAndConvert2 *jettisonpb.Error
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}

func ErrorFromProto(namedInput *jettisonpb.Error) (*models.Error, error) {
	var namedOutput *models.Error

	var transformAndConvert jettisonpb.Error
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 models.Error
	transformAndConvert1.Code = transformAndConvert.Code
	transformAndConvert1.Message = transformAndConvert.Message
	for i := range transformAndConvert.Parameters {
		var tmpOutput models.KeyValue
		var transformAndConvert2 jettisonpb.KeyValue
		if transformAndConvert.Parameters[i] != nil {
			transformAndConvert2 = *transformAndConvert.Parameters[i]
		}
		var transformAndConvert3 models.KeyValue
		transformAndConvert3.Key = transformAndConvert2.Key
		transformAndConvert3.Value = transformAndConvert2.Value

		tmpOutput = transformAndConvert3

		transformAndConvert1.Parameters = append(transformAndConvert1.Parameters, tmpOutput)
	}
	transformAndConvert1.Source = transformAndConvert.Source

	var transformAndConvert2 *models.Error
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}

func KeyValueToProto(namedInput *models.KeyValue) (*jettisonpb.KeyValue, error) {
	var namedOutput *jettisonpb.KeyValue

	var transformAndConvert models.KeyValue
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 jettisonpb.KeyValue
	transformAndConvert1.Key = transformAndConvert.Key
	transformAndConvert1.Value = transformAndConvert.Value

	var transformAndConvert2 *jettisonpb.KeyValue
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}

func KeyValueFromProto(namedInput *jettisonpb.KeyValue) (*models.KeyValue, error) {
	var namedOutput *models.KeyValue

	var transformAndConvert jettisonpb.KeyValue
	if namedInput != nil {
		transformAndConvert = *namedInput
	}
	var transformAndConvert1 models.KeyValue
	transformAndConvert1.Key = transformAndConvert.Key
	transformAndConvert1.Value = transformAndConvert.Value

	var transformAndConvert2 *models.KeyValue
	transformAndConvert2 = &transformAndConvert1

	namedOutput = transformAndConvert2

	return namedOutput, nil
}
